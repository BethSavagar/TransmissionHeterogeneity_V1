---
title: "A Individual Based Branching Process Model of Disease Transmission in a Heterogeneous Population"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Contents:

- [Introduction](#introduction) : Explanation of the Model
- [Functions](#functions) : Code for 3 functions required to run model
- [Example](#example) : Test model function with arbitrary parameters.



*****
### <a id="introduction"></a>INTRODUCTION: 
*****

An individual based model simulating disease spread among individual units (e.g. animals, flocks, villages) within a population. Units may exist in one of 3 disease states: Susceptible (S), Infected (I), Recovered (R) 

The code takes a vector which contains the disease state of each individual unit in the population and simulates a state change (or not) for each unit, depending on their current state, such that the output is a vector of each unit's state at the next timestep. 

3 state changes are possible:  

- **S to I **: the number of secondary cases generated by each infected unit is simulated by a negative binomial distribution with parameters R (the average number of secondary cases produced by an infected case) and k (the dispersion parameter). The newly infected susceptible units are randomly sampled from the susceptible population to generate the new generation of infected units 
- **I to R **: The infectious period of the disease is constant, lasting one timestep/generation, such that every infected unit becomes Recovered in the next generation
- **R to S **: Recovered units can become susceptible again after a fixed period of time. 


*****
### <a id="functions"></a>FUNCTIONS: 
*****
Two functions are written for the state changes: (i) **S-to-I** and (ii) **R-to-S**. The state change **I-to-R** does not require a function since **I** units become **R** with probability p = 1 within a given timestep/generation. 

A third function is written which simulates the state changes of units within the population  over X generations, using the functions for **S-to-I** and **R-to-S**.


#### Function 1: Generating secondary cases (S-to-I)

A function which takes as input a vector of susceptible units and a vector of infected units, generating as output a vector of new infected cases:  

- `S_index`: vector of indices of susceptible units in the population
- `I_index`: vector of indices of infected units in the population (from which new cases are generated)
- `k_estimate`: dispersion parameter which defines the level of overdispersion in secondary cases (negative binomial distribution). 
- `R_estimate`: average number of secondary cases generated from each infected unit
- `cases_index` (output): a vector containing the indices of new cases in the population


```{r}


S_to_I <- function(I_index, S_index, N, k_estimate, R_estimate) {
  
  cases <- length(I_index) # current number of infected units in population
  secondary_cases <- rnbinom(cases,   # number of secondary cases generated, based on NBD
                             size = k_estimate,
                             mu = R_estimate)
  secondary_cases <- secondary_cases[secondary_cases > 0] #subset only those which secondary cases /= 0
  
  #If there are secondary cases generated then sample from the susceptible population to determine identity of new infecteds >>>
  
  if (length(secondary_cases) > 0) {
    cases_index <- vector() #vector to hold ids of new infected cases
    
    # limit the max number of new cases to the number of susceptibles in the population
    Vsize <- secondary_cases
    Vsize[Vsize > N] <- N
    
    # Sample from susceptible units, to generate new case ids
    L <- lapply(Vsize,
                function(x)
                  sample(N, x, replace = FALSE))
    cases_index <- unique(unlist(L)) #ensure no duplications in case ids
    cases_index <- cases_index[cases_index %in% S_index]
    
  }else{ 
    #if no secondary cases are produced then case_index vector <- 0
    cases_index <- numeric(0) 
  }
  return(cases_index)
}

```



#### Function 2: Reverting to Susceptibility (R-to-S)

A function which generates newly susceptible units from previously recovered units after a given time period.

The function takes inputs:  

- `state_tracker` : The matrix containing disease states of population over time (in order to track number of timesteps in R state)
- `R_index`: A vector of ids of all recovered units in the population, at the current timestep
- `R_period` : The number of timesteps/generations which a unit remains recovered/immune after infection, before becoming susceptible again.
- `new_S`: vector of states of R individuals in the next generation (may be R or S)

```{r}

R_to_S <- function(state_tracker, R_index, R_period) {
  
  R_matrix <- state_tracker[R_index, ] # subset state_tracker matrix to contain only units in R state
  
  if(length(R_index == 1)){
    R_counts <- length(which(R_matrix == "R"))
    if(R_counts >= R_period){
      new_S <- "S"
    }else{
      new_S <- "R"
    }
  }else{
  
  # Create a vector to hold the number of timesteps for which a unit has been in R state
    R_counts <-
      apply(R_matrix, MARGIN = 1, function(x) length(which(x == "R")))
  
  # Create a vector to contain the state of R units in the next generation (R or S)
  new_S <- R_index 
  
  # If unit has been in R state for >= R_period then change state to S
  new_S[R_counts >= R_period] <- "S"
  new_S[R_counts < R_period] <- "R"
  }
  
  return(new_S) 
}


```



#### Function 3: Population state tracker

A function which tracks the state change of units within the population over X generations. The function takes as input:  

- `state_tracker` : a matrix with nrow = population size (number of units) and ncol = generations + 1 (number of generations to simulate + 1 column for the initial population state). The first column of the matrix contains the initial state of the population
- `R_period` : The number of timesteps/generations for which a unit remains recovered/immune after infection, before becoming susceptible again.
- `k_estimate` : dispersion parameter which defines the level of overdispersion in secondary cases (negative binomial distribution). Used by the `S_to_I` function.
- `R_estimate` : average number of secondary cases generated from each infected unit. Used by the `S_to_I` function.

```{r}


state_update <- function(state_tracker,
                         R_period,
                         N,
                         k_estimate,
                         R_estimate) {
  
    for (i in 2:ncol(state_tracker)) {
      
      disease_state <- state_tracker[, i - 1] # current state of population
      
      S_index <- which(disease_state == "S") # ids of Susceptible individuals
      I_index <- which(disease_state == "I") # ids of Infected individuals
      R_index <- which(disease_state == "R") # ids of Recovered individuals
      
      new_disease_state <- vector(length = length(disease_state)) # vector to hold disease state of units in population at next timestep
      
      
      ########### UPDATE I UNITS (I --> R) ##############
      # All infecteds become recovered in a given timestep
      
      if (length(I_index) > 0) {
        new_disease_state[I_index] <- "R"
      }
      
      ########### UPDATE R UNITS (R --> S/R) ##############
      ## Recovereds become Susceptible again after being recovered for generations >= R_period 
      
      if (length(R_index) > 1) {
        new_S <- R_to_S(state_tracker, R_index, R_period) # new_S is a vector containing new state of all Rs in population
        new_disease_state[R_index] <- new_S # update status of all Rs in population with new state
      }
      
      ########### UPDATE S UNITS (S --> S/I) ##############
      ## Infected units produce secondary cases according to negative binomial distribution (NBD)
      
      if (length(S_index > 0)) {
        case_index <- S_to_I(I_index, S_index, N, k_estimate, R_estimate)
        new_disease_state[S_index] <- "S"
        new_disease_state[case_index] <- "I"
      }
      
      ########### UPDATE STATE TRACKER ##############
      state_tracker[, i] <- new_disease_state # update column of state_matrix with new population state
      
    }
  
  return(state_tracker)
  }



```




*****
### <a id="example"></a>EXAMPLE: 
*****
See below for set up, simulation and plot. 

#### Set Up:

Given a population of 100 units of which 20 units are initially infected (arbitrarily high to show effect). Simulate the disease state of units in the population for 10 generations 

**Parameters**

- `R_period` : The number of timesteps/generations for which a unit remains recovered/immune after infection, before becoming susceptible again. Set at 3 (arbitrary)
- `k_estimate`: dispersion parameter. Set at 0.18, value for Ebola from Althaus (2015)
- `R_estimate`: R number. Set at 0.95, value for Ebola from Althaus (2015)

```{r}

### SET UP ###

N <- 1000 # Population size
I0 <- 1 # number of index cases

init_state <- c(rep("I", I0), # Initial disease state of units within population
                rep("S", N - I0)
)

generations <- 1000 # number of generations to simulate

state_tracker <- matrix(nrow = N, ncol = 1+generations) # a matrix to contain the disease state of all units over X generations, ncol = 1 + generations with first col containing initial state of population

state_tracker[,1] <- init_state # first col contains initial state of units in population



### PARAMETERS ###

R_period <- 3 # number of timesteps spent in "recovered" state before becoming susceptible again
k_estimate <- 1000 # 0.18 overdispersion parameter for NBD using estimate for Ebola from Althaus 2015
R_estimate <- 1.5 # 0.95 average R using estimate for Ebola from Althaus 2015

```


#### Simulation: 

```{r}

population_state <- state_update(state_tracker, 
                                 R_period,
                                 N,
                                 k_estimate, 
                                 R_estimate)

# Track the numbers of S, I, R units in each generation:

state_numbers <- matrix(nrow = 3, ncol = ncol(population_state)) # A matrix to contain the number of units in each disease state over time
rownames(state_numbers) <- c("S", "I", "R")

for(i in 1:ncol(population_state)){
  state_numbers[1, i] <- length(which(population_state[,i] == "S"))
  state_numbers[2, i] <- length(which(population_state[,i] == "I"))
  state_numbers[3, i] <- length(which(population_state[,i] == "R"))
}

state_numbers <- as.data.frame(state_numbers) #state_numbers contains the number of units in each state (S, I, R) at each timestep/generation

state_numbers$state <- c("S", "I", "R")


```

#### Plot 

```{r}

library(reshape2)
library(ggplot2)
data_long <- melt(state_numbers) # data in long format for ggplot2

ggplot(data = data_long, 
       aes(x = variable, y = value, group = state, colour = state)) +
  geom_line() + 
  scale_colour_hue(name = "State") + 
  xlab("Generation") + ylab("Number of Units") +
  theme_bw()

```

