---
title: "Heterogeneity Model Development - 15.10.20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Contents:

- [Introduction](#introduction) : Model background and explanation
- [Functions](#functions) : Code nad explanation of functions required to run model
- [Example](#example) : Test model function with arbitrary parameters.


#### Set up: Load libraries

```{r}
library(reshape2)
library(ggplot2)

```

### <a id="introduction"></a>INTRODUCTION: 

The following code is an Individual Based Model, following the Reed Frost Method simulating disease spread among individual units (e.g. animals, flocks, villages) within a population. Units may exist in one of 3 disease states: Susceptible (S), Infected (I), Recovered (R) 

The model simulates the state changes of individual units in the population over time. Based on the initial disease state of each unit, the model simulates a state change (or not) for each unit across successive generations. The number and identity of units in each disease state (S, I, R) across generations can be tracked to study disease dynamics.  
A full description of the model is provided alongside the `state_update` function (see below).

3 state changes are possible:  

- **S to I (Infection) **: secondary case generation depends on the number of effective contacts made by each infected unit, simulated by a negative binomial distribution with parameters R (the average number of effective contacts produced by a unit) and k (the dispersion parameter). A unit may only become infected if it is in the Susceptible state in the current generation.
- **I to R (Recovery) **: The infectious period of the disease is constant and equal to 1 timestep in the simulation, such that every infected unit becomes Recovered in the next generation. 
- **R to S (Loss of Immunity) **: Recovered units become susceptible after a set period (number of timesteps) in the R state.


Model behaviour/disease dynamics may be studied based on the following:

- The initial state of the population e.g. immunity level (vaccination) in initial population
- The average effective contact rate of units (R parameter) and the level of overdispersion in contact rates (k parameter)
- The duration of the immune period, the period during which each unit spends in the "Recovered" state prior to reverting to susceptibility. 
*Note: The immune period of each unit may be the same for all units (a simplification) OR heterogeneity in the immune period of each unit may be incorporated to reflect different demographic rates/individual variation * 
- Whether the effective contact potential of a unit is an inherent (fixed) or stochastic (variable) property. 

### <a id="functions"></a>FUNCTIONS: 

The following user defined functions are used in the model. Alongside each function is provided a description of its purpose, an explanation of the arguments required for the function,  a step-wise description of the function, and annotated code.


- [effcChecker](#effcChecker) : Verifies that the number of effective contacts made per unit does not exceed the size of the population (i.e. $<= N$). Used in `S_to_I` and `state_update` functions
- [effcIdGenerator](#effcIdGenerator) : Generates IDs of effectively contacted units by random sampling of the population. Used in `S_to_I` function.
- [S_to_I](#S_to_I) : Generates the next generation of infected units, using `effcChecker` and `effcIdGenerator` functions  
- [state_update](#state_update) : Simulates disease spread throughout the population over successive generations, using `S_to_I` and `effcChecker` functions


___

#### <a id="effcChecker"></a>effcChecker function

___
**Description**

This function is used to validate the number of effective contacts per unit, generated by a negative binomial distribution. The maximum number of effective contacts per unit is N - 1 where N is the total population size (-1, since no self-self contacts are made). 

___

**Function specifics**

A function which takes as input a vector containing the raw number of effective contacts per unit and generates as output a validated vector of effective contacts per unit where no unit makes >= N contacts.

- `effc_num`: A vector containing the raw number of effective contacts per unit, drawn from a negative binomial distribution
- `N` : The total population size, required to define the maximum number of contacts per unit
- `k-estimate`: Overdispersion parameter required for the Negative Binomial Distribution, run if the number of effective contacts for any unit needs to be redrawn (>= N)
- `R-estimate`: Mean parameter required for the Negative Binomial Distribution, run if the number of effective contacts for any unit needs to be redrawn (>= N)

**Code: **

```{r}

effcChecker <- function(effc_num, N, k_estimate, R_estimate) {
  
  # First identify whether any units produced >= N effective contacts
  # The vector effc_N_id stores the position of infected units which generate >= N effective contacts
  effc_N_id <- which(effc_num >= N)
  
  # Check whether any units have >= N effective contacts ( length(effc_N_id) > 0)
  # If so, use a for loop to iterate over each unit which makes >= N effective contacts (ids stored in effc_N_id)
  # For a given unit (which makes >= N effc) use a while loop to re-run the negative binomial simulation (using the parameters of R and k) to generate a new number of effective contacts for that unit
  # Continue to re-run the negative binomial simulation until the number of effective contacts is less than N.
  # When the number of effective contacts for the infected unit is < N break the loop and update the effc_num vector with the new value 
  
  
  if (length(effc_N_id) > 0) {
    for (i in effc_N_id) { # iterate over the vector effc_N_id which contains IDs of units generating >= N effective contacts
      
      effc_i <- effc_num[i] # assign variable effc_i to the number of effective contacts for the indexed unit (position i in effc_num vector)
      
      # Use a while loop to re-run the negative binomial simulation of effective contacts for the indexed unit (effc_i) until the number of effective contacts is < N.
      while (effc_i >= N) {
        new_i <- rnbinom(1, # simulate for single infected unit
                         size = k_estimate, # dispersion parameter
                         mu = R_estimate) # average number of effective contacts
        effc_i <- new_i # update effc_i within while loop
      }
      
      # Update the effc_num vector with the new, valid, number of effective contacts for the unit.
      effc_num[i] <- effc_i 
    }
  }
  return(effc_num) # return the validated effc_num vector
}


```


___

#### <a id="effcIdGenerator"></a> effcIdGenerator function
___
**Description**

This function is used to generate the IDs of effectively contacted units, using random sampling of the total population. Any unit can be effectively contacted regardless of its state, the output of the function is a vector of all effectively contacted unit IDs (including units in S, I, R states).

___

**Function specifics**

The function takes as input a vector containing the number of effective contacts per infected unit (effc) and the infected unit ID (effc_id), samples effective contacts from the population (excluding the infected unit) and produces as output a vector of effectively contacted unit IDs

- `effc` : A vector containing the number of effective contacts for each infected unit (with effective contacts >0)
- `effc_id` : A vector containing the ids of infected units which made >0 effective contacts, used to prevent self-self contacts
- `N` : The total population size, required for sampling effective contacts

**Code: **

```{r}

effcIdGenerator <- function(effc, effc_id, N) {
  Vsize <- effc # temporary vector Vsize contains the number of effective contacts for each infected unit (where effective contacts are non-zero)
  
  # Sample from all units in population to generated effectively contacted unit ids.
  # Use effc_id to remove the possibility of a self-self contact.
  # The list (L) contains the ids of effectively contacted units for each infected unit (with effc>0), simulated by random sampling of the population.
  L <- lapply(1:length(Vsize),
              function(x)
                sample((1:N)[-effc_id[x]], # Sample contacted unit ids from the total population (N), excluding the current infected unit (defined by effc_id[x])
                       Vsize[x], # The number of ids sampled is defined by the number of effective contacts made by the 'x' Infected unit.
                       replace = FALSE)) # Once contacted a unit cannot be contacted again by the same infected unit.
  
  # Transform the list of contact ids into a vector which contains no duplicate ids (i.e. if a unit is contacted by two different infected units it is only recorded once, since a unit cannot be infected twice in 1 timestep)
  
  contact_ids <- unique(unlist(L)) # contact_ids is a vector which stored the ids of all units which are effectively contacted by an infected unit
  
  return(contact_ids) #return the contact_ids vector
}


```



___

#### <a id="S_to_I"></a>S_to_I transition: Generating secondary cases 

___

**Description**

This function is used to generate a vector of ids of new infected units from a vector of susceptible units and a vector of infected units.  
The function uses the negative binomial distribution to simulate the number of 'effective contacts' per infected unit.  
The 'effective contact potential' of a given unit may be fixed (remaining constant across timesteps) or stochastic (contact potential is random and variable between timesteps)

- When heterogeneity is **fixed** the effective contact potential of a given unit remains constant across timesteps, and can be considered an inherent property of that unit.
- When heterogeneity is **variable** the effective contact potential of a given unit can vary from timestep to timestep (redrawn from a negative binomial distribution), and can be considered a stochastic property

The ids of contacted units are sampled from the population based on the number of effective contacts (without duplication)  
Contacted units which are in the susceptible state become new infected units. All other units (I or R state) are unchanged by this function.  

___

**S_to_I Function specifics**  

A function which takes as input a vector of susceptible units and a vector of infected units, generating as output a vector of new infected units:  

- `I_index`: vector of ids of infected units in the population (from which new cases are generated)
- `S_index`: vector of ids of susceptible units in the population
- `N` : The size of the population
- `k_estimate`: dispersion parameter which defines the level of overdispersion in effective contacts (used negative binomial distribution). 
- `R_estimate`: average number of effective contacts generated from each infected unit (used negative binomial distribution).
- `heterogeneity` : defines whether the 'effective contact potential' of each unit is fixed or variable across timesteps. Takes values of either "fixed" or "variable".
- `fixed_effc` : a vector storing the 'effective contact potential' of each unit in the population, generated by a negative binomial distribution, to be used when `heterogeneity == "fixed"`

- `cases_index` (output): a vector containing the ids of new infected units in the population

Additional user defined functions used within S_to_I:

- [effcChecker](#effcChecker) : Verifies that the number of effective contacts per unit is <= N
- [effcIdGenerator](#effcIdGenerator) : Generates IDs of effectively contacted units but random sampling of the population

**Code: **

```{r}

# The S_to_I function takes as arguments: the ids of infected units (I_index), the ids of susceptible units (S_index), the population size (N), an estimate of the overdispersion of effective contacts (k_estimate), the average number of effective contacts per infected unit (R_estimate), an argument to define whether the effective contact potential of units is fixed or variable across timesteps (heterogeneity) and a vector of effective contact potentials for each unit (fixed_effc, for use when heterogeneity == "fixed")


S_to_I <- function(I_index,
                   S_index,
                   N,
                   k_estimate,
                   R_estimate,
                   heterogeneity, # defines whether the effective contact potential of units is fixed or variable across timesteps
                   fixed_effc # stores the effective contact potential of units, required when heterogeneity is fixed across timesteps
                   ) {
  # In 2 steps: (i) Simulate the number of effective contacts per infected unit, (ii) Generate secondary cases (from effective contacts with S units)
  
  # ------------------------------------------------------------------------------------------
  ## SIMULATE NUMBER OF EFFECTIVE CONTACTS PER INFECTED UNIT
  # ------------------------------------------------------------------------------------------
  # Calculate the number of effective contacts made by each infected unit in a given timestep

  ## Heterogeneity == FIXED ##
  # When heterogeneity == "fixed" the effective contact potential of each unit is constant across timesteps and is stored in the vector fixed_effc

    if (heterogeneity == "fixed") { 
      
      # define effc_num vector to store the effc value (stored in fixed_effc) for infected individuals 
      effc_num <- fixed_effc[I_index] # subsetting effc_fixed vector with I_index
      
    ## Heterogeneity == VARIABLE ##   
    # When heterogeneity == "variable" the effective contact potential of each unit can vary across timesteps (i.e. stochastic), redrawn from the Negative Binomial Distribution each timestep.  
      
    } else if (heterogeneity == "variable") { 
      
      I0 <- length(I_index) # the number of currently infected cases
      
      # define vector effc_raw to store the number of effective contacts for each infected unit (drawn from a Negative Binomial Distribution)
      effc_raw <-
        rnbinom(I0,   # I0 is the number of infected units in the population (defines number of elements in effc_raw vector)
                size = k_estimate, # dispersion parameter of effective contacts
                mu = R_estimate) # average number of effective contacts for a unit in the population
      
      ## Effective Contact Verification ##
      # verify that no unit produces >= N effective contacts (an impossibility) using the effcChecker function (see above)
      effc_num <- effcChecker(effc_raw, N, k_estimate, R_estimate) 
      
    }
    
    # ------------------------------------------------------------------------------------------
    ## GENERATE IDs of SECONDARY CASES
    # ------------------------------------------------------------------------------------------
    # 2 step process: (i) Contact IDs (all units), (ii) Case IDs (only S units)

    # If the number of effective contacts (effc) is non-zero simulate contacts between units in the population by random sampling
    # An 'effective contact' can occur between an infected unit and any other unit in the population, excluding itself (ie units in S, I or R state can be contacted). See effcIdGenerator   
    # A contacted unit only becomes infected if it is in the S state (see line 287)
  
    ## Clean the effc vector ##
  
    # subset the 'effc_num' vector to contain only non-zero effective contacts
    effc <- effc_num[effc_num > 0] # this will be used to simulate contacts between units in the population using random sampling.
    
    ## Store Infected Unit (with non-zero contacts) IDs: ##
    
    # A vector 'effc_id' is defined which store the ids of infected units which generated more than 0 effective contacts (effc_num > 0)
    # this will be used to ensure that no self-self contacts are simulated 
    effc_id <- I_index[effc_num > 0]
    
    
    ## Generate Contact IDs ##
    
    # If >0 effective contacts are made (i.e. length(effc)>0) use effcIdGenerator to produce list of effectively contacted unit ids 
    
    if (length(effc) > 0) {
      
      contact_ids <- effcIdGenerator(effc, effc_id, N)  # effcIdGenerator produces a list of effectively contacted unit ids (stored in contact_ids vector) using random sampling of population IDs (see effcIdGenerator code)
      
      ## Generate Case IDs ##
    
      # Define the cases_index vector to store the ids of newly infected units (effectively contacted S units)
      # Cases are generated from effective contacts between an infected unit and a susceptible unit
      # Within the vector of contacted unit ids (contact_ids), identify those ids which are in the Susceptible state (S_index)
      
      cases_index <- contact_ids[contact_ids %in% S_index]
      
    } else{
      #if no secondary cases are produced then case_index vector <- 0
      cases_index <- numeric(0)
    }
    
    return(cases_index)
  }


```


___

#### <a id="state_update"></a> state_update : Simulating disease spread
___

**Description**

This function is used to simulate the disease state of individual units within a population over time. 
The function takes the initial state of the population and updates state of each unit across successive timesteps.
The units may remain in the same state or undergo infection, recovery or loss of immunity in a given timestep
The changing state of units across time is tracked and provided as output which can be used to study disease dynamics.

___

**Function specifics**


A function which tracks the state change of units within the population over successive generations. The function takes as input:  

- `state_tracker` : a matrix of 1 column containing the initial state of each unit in the population. The number of rows = the number of units in the population. This matrix will be updated to contain the status of units over successive timesteps.
- `generations` : the number of timesteps over which to simulate the population.
- `R_period` : The number of timesteps for which a unit remains recovered/immune after infection, before becoming susceptible again.
- `N` : The number of units in the population
- `heterogeneity` : defines whether the effective contact potential of each unit is (i) "fixed" or (ii) "variable". If "fixed" each unit has a predetermined effective contact potential, remaining constant across timesteps. If "variable" the effective contact potential of each unit may vary across timesteps. 
- `k_estimate` : dispersion parameter which defines the level of overdispersion in secondary cases (negative binomial distribution). Used by the `S_to_I` function.
- `R_estimate` : average number of secondary cases generated from each infected unit. Used by the `S_to_I` function.
- `output` : defines whether the model returns (i) "matrix", or (ii) "counts". If "matrix", the output is a matrix which tracks the state of each unit over time. If "counts", the output is a dataframe tracking the number of units in each state (S, I, R) over time. 

Additional User Defined Functions used within `state_update`:

- [S_to_I](#S_to_I) : Generates secondary cases (newly infected units)
- [effcChecker](#effcChecker) : Validates the number of effective contacts per unit
- [effcIdGenerator](#effcIdGenerator) : Generates IDs of effectively contacted units by random sampling of the population


**THE MODEL **

**Pre-simulation prep **

- Define a vector, RTime, to track the number of timesteps each unit has spent in the recovered (R) state (initiated with 0s), the value will reset to 0 when the unit loses its immune status (R --> S)
- Define a vector to store the effective contact potential of each unit, drawn from a Negative Binomial Distribution, used when a unit's effective contacts remain constant through time. 

**Simulation:**

Complete the simulation for the number of timesteps defined in the 'generations' parameter, using a FOR loop.

Set up 

- Define the current state of the population
- Identify units in each disease state
- Define a vector to store the state of the population at the next timestep (new_disease_state)

Recovery:

- Update the status of units in the "I" state
- Update all Infected units to "Recovered" and store in the new_disease_state vector
- The infection period is equal to 1 timestep hence all infected units become recovered in a given timestep.

Loss of Immunity:

- Update the status of units in the "R" state
- Update the vector tracking the time each unit has spent in the "R" state (+1 timestep)
- The maximum period spent in the R state is defined by the R_period variable which reflects the immune period of a unit (in number of timesteps spent immune)
- For units which have spent less time in the R state than defined by R_period, their status will remain as "R" in the new_disease_state vector
- For units which have been in the R state for the number of timesteps defined by R_period, update their status to "S" in the new_disease_state vector


Infection:

- Update the status of units in teh "S" state
- Use to `S_to_I` function to generate IDs of new infected units, stored in the cases_index vector
- Update the status of units identified in the cases_index vector to "I" in the new_disease_state vector
- All other susceptible units will remain in the "S" state in the new_disease_state vector.


Matrix Update:

- update the state_tracker matrix with the new_disease_vector, to track the status of units in the population over time.
- Calculate the number of units in each disease state (S, I, R) and store in a data frame

Output:

- The format of the output is defined by the output argument in the state_update function, which can take values of either (i) matrix, or (ii) counts
- If the output argument is defined as "matrix" the state_tracker matrix is returned, which contains the state of each unit in the population across time
- If the output argument is defined as "counts" a dataframe is returned, which contains only the number (not the identity) of units in each state across time.




**Code: **

```{r}


state_update <- function(state_tracker, # vector of initial population states
                         generations, # number of timesteps to run simulation 
                         R_period, # the immune period (number of timesteps spent in recovered state)
                         N, # population size
                         heterogeneity, # is heterogeneity in effective contacts "fixed" or "variable"
                         k_estimate, # overdispersion parameter, level of heterogeneity in effective contact potential
                         R_estimate, # average number of effective contacts per unit
                         output # defines the output as "matrix" or "counts"
                         ) {
  
  
  # -------------
  ## SET UP ##
  # -------------
  
  # Create a vector to store the number of timesteps spent in R state
  # this will ensure that units spend the number of generations defined by R_period in the "R" state before reverting to susceptibility
  RTime <- c(rep(0, N))
  
  
  # Define the effective contact potential of units, when heterogeneity == "fixed"
  # If the number of effective contacts per unit is fixed over time then define a vector "effc_fixed" to contain the number of contacts per unit in the population.
  fixed_effc <- rnbinom(N,
                      size = k_estimate, 
                      mu = R_estimate)
  
  # Use effcChecker function to validate that the number of effective contacts per unit does not exceed the total population size
  fixed_effc <- effcChecker(fixed_effc, N, k_estimate, R_estimate)
  
  
  # Set the initial state of the population, this will be updated with each iteration of the generations FOR loop below.
  
  disease_state <- state_tracker
  
   
  # Create vectors to store the number of units in each state per generation, only if the output is "counts"

  if(output == "counts"){
    S_counts <- sum(disease_state == "S")
    I_counts <- sum(disease_state == "I")
    R_counts <- sum(disease_state == "R")
  }
  
  # --------------
  ## SIMULATION ##
  # --------------
  
  for (i in 2:generations) { # run the simulation for the number of timsteps specified in 'generations' variable
    
    S_index <- which(disease_state == "S") # ids of Susceptible individuals
    I_index <- which(disease_state == "I") # ids of Infected individuals
    R_index <- which(disease_state == "R") # ids of Recovered individuals
    
    new_disease_state <-
      vector(length = length(disease_state)) # vector to hold disease state of units in population at next timestep
    
    # ------------
    ## RECOVERY ##
    # ------------
    
    # All infecteds become recovered in a given timestep
    
    if (length(I_index) > 0) {
      new_disease_state[I_index] <- "R"
    }
    
    
    # -------------------------------
    ## LOSS OF IMMUNITY ##
    # -------------------------------
    
    ## Recovereds become Susceptible again after being in R_state for >= R_period timesteps
    
    if (length(R_index) > 0) {
      RTime[R_index] <- RTime[R_index] + 1 # update R units in RTime vector to reflect +1 timestep in R state
      newS_index <- which(RTime == R_period) # identify units which have been in R state for >= ~R_period, store in newS_index
      
      # Update RTime vector for units reverting to susceptibility
      RTime[newS_index] <- 0 # becomes 0 since units are no longer immune
      
      # Update new_disease_state vector
      new_disease_state[R_index] <- "R"
      new_disease_state[newS_index] <- "S" # units identified in newS_index lose immunity
    }
    
    
    # -----------
    ## INFECTION
    # -----------
    
    ## Infected units produce secondary cases according to negative binomial distribution (NBD)
    # See the S_to_I function description above for a detailed explanation
    # S_to_I takes a vector of susceptible units and a vector of infected units and generated new infected units (cases) based on anegative binomial distribution. 
    # S_to_I outputs a vector (cases_index) storing the ID of new infected units (cases)
    
    if (length(S_index > 0)) {
      cases_index <- S_to_I(I_index,
                            S_index,
                            N,
                            k_estimate,
                            R_estimate,
                            heterogeneity, # heterogeneity variable determines whether unit effective contacts are fixed or variable over time.
                            fixed_effc # stores the effective contact potential of units, used if heterogeneity == "fixed"
                            ) 
      new_disease_state[S_index] <- "S" # all S units remain in S state
      new_disease_state[cases_index] <- "I" # update ids of units in cases_index to "I"
    }
    
    # -----------------------
    ## UPDATE STATE MATRIX // COUNTS ##
    # -----------------------
    
    if (output == "matrix"){
      
      state_tracker <-
        cbind(state_tracker, new_disease_state) # update column of state_matrix with new population state
      
    }else if (output == "counts"){
      
      # update vectors containing counts of units in each disease state over time
      
      S_counts <- c(S_counts, sum(new_disease_state == "S"))
      I_counts <- c(I_counts, sum(new_disease_state == "I"))
      R_counts <- c(R_counts, sum(new_disease_state == "R"))
      
    }
    
    # update the disease state of the population for the next loop
    disease_state <- new_disease_state
   
  } 
  ## END OF FOR LOOP
  
  # -----------------------
  ## DEFINE OUTPUT ##
  # -----------------------
  
  # Define the formate of the function output, as specified by the 'output' argument
  # If output is set to 'matrix' return the full matrix containing the disease state of each individual unit over time
  # If output is set to 'counts' return a dataframe tracking only the number (not the identity) of units in each disease state over time
  
  if (output == "matrix") {
    
    #rename state_tracker columns as generation number
    colnames(state_tracker) <- seq(1:generations)
    
    return(state_tracker) # return the full matrix tracking the state of each unit in the population across time
    
  } else if (output == "counts") {
    
    # bind state_count vectors into a data_frame called state_counts, with each disease state occupying a different row (S, I, R)
    state_counts <- as.data.frame(rbind(S_counts, I_counts, R_counts))
    # rename columns and rows of state_counts 
    colnames(state_counts) <- seq(1:generations)
    rownames(state_counts) <- c("S", "I", "R")
  
    return(state_counts) # return the number (but not ID) of units in each state across time
  }
  
}



```

### <a id="example"></a>EXAMPLE: 


#### Parameters

- `R_period` : The number of timesteps/generations for which a unit remains recovered/immune after infection, before becoming susceptible again. Set at 3 (arbitrary)
- `k_estimate`: dispersion parameter. Value is arbitrary for example below
- `R_estimate`: R number. Value is arbitrary for example below

```{r}

### SET UP ###

N <- 1000 # Population size
I0 <- 1 # number of index cases

generations <- 100 # number of generations to simulate

init_state <- c(rep("I", I0), # Initial disease state of units within population
                rep("S", N - I0)
)
#state_tracker <- as.matrix(init_state) # A matrix with 1 column which contains the initial state of each unit in the population, nrow = N (number of units in population)
state_tracker <- init_state


### PARAMETERS ###

R_period <- 4 # number of timesteps spent in "recovered" state before becoming susceptible again
k_estimate <- 1000 # overdispersion parameter for NBD - 0.18 for Ebola from Althaus 2015
R_estimate <- 3 # average R using estimate for NBD - 0.95 for Ebola from Althaus 2015

```


#### Model simulation

```{r}
# Run state_update function with parameters specified above

population_state <- state_update(state_tracker,
                                 generations,
                                 R_period,
                                 N,
                                 heterogeneity = "fixed",
                                 k_estimate, 
                                 R_estimate,
                                 output = "matrix")


state_numbers <- state_update(state_tracker,
                              generations,
                              R_period,
                              N,
                              heterogeneity = "fixed",
                              k_estimate,
                              R_estimate,
                              output = "counts")

population_state[1:5, 1:10]
state_numbers[1:3, 1:10]

```

#### Plot 

```{r}

library(reshape2)
library(ggplot2)

state_numbers$state <- c("S", "I", "R") # define which disease state each row corresponds to, required for melt() function
  
data_long <- melt(state_numbers) # data in long format for ggplot2

ggplot(data = data_long, 
       aes(x = variable, y = value, group = state, colour = state)) +
  geom_line() + 
  scale_colour_hue(name = "State") + 
  xlab("Generation") + ylab("Number of Units") +
  theme_bw()

```


